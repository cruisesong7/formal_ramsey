-- import combinatorics.pigeonhole
import Mathlib.Combinatorics.SimpleGraph.Clique
-- import data.fin.vec_notation

import FormalRamsey.PickTactic
import FormalRamsey.Utils

def graphAtColor {N k : ℕ} (G : SimpleGraph (Fin N)) (ϕ : Sym2 (Fin N) → Fin k)
 (i : Fin k): SimpleGraph (Fin N) := {
  Adj := λ u v ↦ (G.Adj u v) ∧ (ϕ ⟦(u, v)⟧ = i),
  symm := by
    unfold Symmetric
    intros _ _ h
    rcases h with ⟨Gxy,ϕxy⟩
    apply And.intro
    apply G.symm Gxy
    rw [Sym2.eq_swap]
    exact ϕxy,
  loopless :=  by
    unfold Irreflexive
    intros _ h
    simp at h
 }

def RamseyProp (N k : ℕ) (s : Vector ℕ k) : Prop := N > 0 ∧
∀ f : Sym2 (Fin N) → Fin k,
(∃ S i, (graphAtColor (completeGraph (Fin N)) f i).IsNClique (s.get i) S) 

def Ramsey₂Prop (N s t : ℕ) : Prop := RamseyProp N 2 ⟨[s, t], by simp⟩

-- lemma Ramsey_monotone : ∀ {N k s}, Ramsey_prop N k s → ∀ {M}, N ≤ M 
-- → Ramsey_prop M k s :=
-- begin
-- unfold Ramsey_prop,
-- intros _ _ _ R _ NleqM,
-- rcases R with ⟨Ngt0, R⟩,
-- split,
-- linarith only[Ngt0, NleqM],
-- intros,
-- let f' : sym2 (fin N) → fin k := λ e, f (sym2.map (fin.cast_le NleqM) e),
-- cases (R f') with S Sprop,
-- rcases Sprop with ⟨i, Sclique, Scard⟩,
-- use [finset.map (fin.cast_le NleqM).to_embedding S, i],
-- constructor,
-- simp [graph_at_color, simple_graph.is_clique_iff, set.pairwise] at Sclique ⊢,
-- intros _ ainS b binS aneqb,
-- have ScliqueMap := Sclique ainS binS aneqb,
-- simp [f'] at ScliqueMap,
-- exact ScliqueMap,
-- simp [Scard],
-- end

-- theorem Ramsey₂_prop_symm : ∀ N s t, Ramsey₂_prop N s t ↔ Ramsey₂_prop N t s :=
-- begin
-- have helper : ∀ N s t, Ramsey₂_prop N s t → Ramsey₂_prop N t s,
-- simp [Ramsey₂_prop, Ramsey_prop],
-- intros _ _ _ Ngt0 R,
-- split,
-- exact Ngt0,
-- intro,
-- let f' : sym2 (fin N) → fin 2 := λ e, if f e = 0 then 1 else 0,
-- cases (R f') with S Sprop,
-- rcases Sprop with ⟨i, ⟨Sclique, Scard⟩⟩,
-- use S,
-- fin_cases i,
-- use 1,
-- simp [f', vector.nth] at Sclique Scard ⊢,
-- constructor,
-- simp [simple_graph.is_clique_iff, set.pairwise, graph_at_color] at Sclique ⊢,
-- intros _ xinS _ yinS xneqy,
-- have fxyneq0 := (Sclique xinS yinS xneqy).right,
-- let fxy := f ⟦(x, y)⟧,
-- fin_cases fxy,
-- simp [fxy, ← this] at fxyneq0,
-- cases fxyneq0,
-- simp [xneqy, ← fxy, this],
-- assumption,
-- use 0,
-- simp [f', vector.nth] at Sclique Scard ⊢,
-- constructor,
-- simp [simple_graph.is_clique_iff, set.pairwise, graph_at_color] at Sclique ⊢,
-- intros _ xinS _ yinS xneqy,
-- have fxyeq0 := (Sclique xinS yinS xneqy).right,
-- let fxy := f ⟦(x, y)⟧,
-- fin_cases fxy,
-- simp [fxy, ← this] at fxyeq0,
-- simp [xneqy, ← fxy, this],
-- have fxyneq0 : ¬f ⟦(x, y)⟧ = 0,
-- simp [fxy] at this,
-- simp [this],
-- simp[fxyneq0] at fxyeq0,
-- cases fxyeq0,
-- assumption,

-- intros,
-- use ⟨helper N s t, helper N t s⟩,
-- end

-- theorem friendship_upper_bound : Ramsey₂_prop 6 3 3 :=
-- begin
-- unfold Ramsey₂_prop Ramsey_prop,
-- split,
-- simp,
-- intros,
-- let g : ((complete_graph (fin 6)).neighbor_set 0) → fin 2 := λ x, f ⟦(0, x)⟧,
-- have ghyp : fintype.card (fin 2) • 2 < fintype.card ↥((complete_graph (fin 6)).neighbor_set 0),
-- simp,
-- linarith,
-- have ghyp := fintype.exists_lt_card_fiber_of_mul_lt_card g ghyp,
-- rcases ghyp with ⟨c, chyp⟩,
-- pick 3 from (finset.filter (λ (x : ↥((complete_graph (fin 6)).neighbor_set 0)), g x = c) finset.univ) with x y z,
-- simp [g] at x.elem y.elem z.elem,
-- cases nat.eq_zero_or_pos (finset.filter (λ e, e = c) (insert (f ⟦(↑x, ↑y)⟧) (insert (f ⟦(↑y, ↑z)⟧) (insert (f ⟦(↑x, ↑z)⟧) (∅:(finset (fin 2))))))).card,
-- rotate,
-- pick 1 from (finset.filter (λ (e : fin 2), e = c) {f ⟦(↑x, ↑y)⟧, f ⟦(↑y, ↑z)⟧, f ⟦(↑x, ↑z)⟧}) with e,
-- simp at e.elem,
-- rcases e.elem with ⟨eval, ecolor⟩,
-- have c0 : ∃ a b : (fin 6), (graph_at_color (complete_graph (fin 6)) f c).is_n_clique 3 {0, a, b},
-- rcases eval with eval | ⟨eval | eval⟩; rw eval at ecolor,

-- use [↑x, ↑y],
-- simp [graph_at_color, complete_graph],
-- constructor,
-- simp [simple_graph.is_clique_iff, set.pairwise],
-- rw [@sym2.eq_swap (fin 6) ↑x 0, @sym2.eq_swap (fin 6) ↑y 0, @sym2.eq_swap (fin 6) ↑y ↑x],
-- tauto,
-- rw finset.card_eq_three,
-- use [0, ↑x, ↑y],
-- simp,
-- split,
-- exact x.prop,
-- split,
-- exact y.prop,
-- intro xeqy,
-- change ↑x < ↑y at x.lt.y,
-- simp [xeqy] at x.lt.y,
-- exact x.lt.y,

-- use [↑y, ↑z],
-- simp [graph_at_color, complete_graph],
-- constructor,
-- simp [simple_graph.is_clique_iff, set.pairwise],
-- rw [@sym2.eq_swap (fin 6) ↑y 0, @sym2.eq_swap (fin 6) ↑z 0, @sym2.eq_swap (fin 6) ↑z ↑y],
-- tauto,
-- rw finset.card_eq_three,
-- use [0, ↑y, ↑z],
-- simp,
-- split,
-- exact y.prop,
-- split,
-- exact z.prop,
-- intro yeqz,
-- change ↑y < ↑z at y.lt.z,
-- simp [yeqz] at y.lt.z,
-- exact y.lt.z,

-- use [↑x, ↑z],
-- simp [graph_at_color, complete_graph],
-- constructor,
-- simp [simple_graph.is_clique_iff, set.pairwise],
-- rw [@sym2.eq_swap (fin 6) ↑x 0, @sym2.eq_swap (fin 6) ↑z 0, @sym2.eq_swap (fin 6) ↑z ↑x],
-- tauto,
-- rw finset.card_eq_three,
-- use [0, ↑x, ↑z],
-- simp,
-- split,
-- exact x.prop,
-- split,
-- exact z.prop,
-- intro xeqz,
-- have x.lt.z : x < z,
-- transitivity y,
-- exact x.lt.y,
-- exact y.lt.z,
-- change ↑x < ↑z at x.lt.z,
-- simp [xeqz] at x.lt.z,
-- exact x.lt.z,

-- rcases c0 with ⟨a, b, clique0ab⟩,
-- fin_cases c,

-- use [{0, a, b}, 0],
-- assumption,

-- use [{0, a, b}, 1],
-- assumption,

-- simp at h,
-- rw finset.filter_eq_empty_iff {f ⟦(↑x, ↑y)⟧, f ⟦(↑y, ↑z)⟧, f ⟦(↑x, ↑z)⟧} at h,
-- simp at h,
-- rcases h with ⟨fxyneqc, fyzneqc, fxzneqc⟩,

-- have temp1: f ⟦(↑x, ↑y)⟧ = f ⟦(↑y, ↑z)⟧ := notc fxyneqc fyzneqc,
-- have temp2: f ⟦(↑x, ↑y)⟧ = f ⟦(↑x, ↑z)⟧:= notc fxyneqc fxzneqc,
-- have d0 :(graph_at_color (complete_graph (fin 6)) f  (f ⟦(↑x, ↑y)⟧)) .is_n_clique 3 {↑x, ↑ y, ↑ z},
-- simp [graph_at_color, complete_graph],
-- constructor,
-- simp [simple_graph.is_clique_iff, set.pairwise],
-- rw [@sym2.eq_swap (fin 6) ↑y x, @sym2.eq_swap (fin 6) ↑z y, @sym2.eq_swap (fin 6) ↑z ↑x],
-- tauto,
-- rw finset.card_eq_three,
-- use [↑x, ↑y, ↑z],
-- simp,
-- split,

-- intro xeqy,
-- change ↑x < ↑y at x.lt.y,
-- simp [xeqy] at x.lt.y,
-- exact x.lt.y,

-- split,

-- intro xeqz,
-- have x.lt.z : x < z,
-- transitivity y,
-- exact x.lt.y,
-- exact y.lt.z,
-- change ↑x < ↑z at x.lt.z,
-- simp [xeqz] at x.lt.z,
-- exact x.lt.z,

-- intro yeqz,
-- change ↑y < ↑z at y.lt.z,
-- simp [yeqz] at y.lt.z,
-- exact y.lt.z,

-- let d := f ⟦(↑x, ↑y)⟧,
-- fin_cases d using hd; simp [← d, hd] at d0,

-- use [{↑x,↑y,↑z},0],
-- assumption,

-- use [{↑x,↑y,↑z},1],
-- assumption,

-- end

-- noncomputable def Ramsey₂ (s t : ℕ) : ℕ := Inf { N : ℕ | Ramsey₂_prop N s t }

-- theorem Ramsey₂2 : ∀ k : ℕ, Ramsey₂ 2 k.succ = k.succ :=
-- begin
-- intros,
-- unfold Ramsey₂,
-- have Ramsey₂2_monotone : ∀ M₁ M₂, M₁ ≤ M₂ → M₁ ∈ { N : ℕ | Ramsey₂_prop N 2 k.succ } 
-- → M₂ ∈ { N : ℕ | Ramsey₂_prop N 2 k.succ },
-- intros M₁ M₂ M₁leM₂,
-- simp,
-- intro M₁Ramsey,
-- apply Ramsey_monotone M₁Ramsey M₁leM₂,
-- rewrite nat.Inf_upward_closed_eq_succ_iff (Ramsey₂2_monotone),
-- simp,
-- split,
-- simp [Ramsey₂_prop, Ramsey_prop],
-- intros,
-- cases finset.eq_empty_or_nonempty (finset.filter 
-- (λ (x : sym2 (fin k.succ)), (x.out.1 ≠ x.out.2) ∧ f x = 0) finset.univ),
-- rw finset.filter_eq_empty_iff at h,
-- simp at h,
-- use finset.univ,
-- use 1,
-- constructor,
-- simp [graph_at_color, vector.nth, simple_graph.is_clique_iff, set.pairwise],
-- intros _ _ xneqy,
-- let fxy := f ⟦(x, y)⟧,
-- fin_cases fxy using fxyval,
-- simp [fxy] at fxyval,
-- cases (fin.decidable_eq (k + 1) ⟦(x, y)⟧.out.fst  ⟦(x, y)⟧.out.snd) with xyoutneq xyouteq,
-- cases h ⟦(x, y)⟧ xyoutneq fxyval,
-- rw ← sym2.is_diag_iff_proj_eq at xyouteq,
-- simp at xyouteq,
-- contradiction,
-- simp [← fxy, fxyval, xneqy],
-- simp [vector.nth],
-- cases h with e eprop,
-- simp at eprop,
-- use [{e.out.fst, e.out.snd}, 0],
-- constructor,
-- simp [simple_graph.is_clique_iff, graph_at_color, set.pairwise],
-- split,
-- intro h,
-- exact eprop,
-- intro h,
-- simp [sym2.eq_swap],
-- split,
-- exact h,
-- exact eprop.right,
-- simp [vector.nth,finset.card_eq_two],
-- use [(quotient.out e).fst, (quotient.out e).snd],
-- simp[eprop.left],

-- unfold Ramsey₂_prop,
-- unfold Ramsey_prop,
-- simp,
-- intro,
-- let f : sym2 (fin k) → fin 2 := λ e, 1,
-- use f,
-- by_contra,
-- simp at h,
-- rcases h with ⟨ S, ⟨ i, S_prop ⟩ ⟩ ,
-- fin_cases i,

-- rw simple_graph.is_n_clique_iff at S_prop,
-- rcases S_prop with ⟨SisClique,S_card⟩,
-- unfold graph_at_color at SisClique,
-- simp [simple_graph.is_clique_iff, set.pairwise, graph_at_color] at SisClique,
-- simp [vector.nth,finset.card_eq_two] at S_card,
-- rcases S_card with ⟨x,y,⟨xneqy,Sxy⟩ ⟩ ,
-- have xins : x ∈ S := by rw Sxy; simp,
-- have yins : y ∈ S := by rw Sxy; simp,
-- exact SisClique xins yins xneqy,

-- have kcard : fintype.card (fin k) < k.succ := by simp; apply nat.le_refl,
-- have cliquefree : (graph_at_color (complete_graph (fin k)) f 1).clique_free k.succ :=
-- by apply simple_graph.clique_free_of_card_lt kcard,
-- unfold simple_graph.clique_free at cliquefree,
-- have Scontra :=  cliquefree S,
-- contradiction,
-- end

-- theorem Ramsey₂1_prop : ∀ N k : ℕ, Ramsey₂_prop N.succ 1 k :=
-- begin
-- intros,
-- simp [Ramsey₂_prop, Ramsey_prop],
-- intros,
-- use [{0}, 0],
-- constructor,
-- simp [simple_graph.is_clique_iff, set.pairwise],
-- simp [vector.nth]
-- end

-- theorem Ramsey₂1 : ∀ k : ℕ, Ramsey₂ 1 k.succ = 1 :=
-- begin
-- intro,
-- simp [Ramsey₂],
-- have Ramsey1_monotone : ∀ M₁ M₂, M₁ ≤ M₂ → M₁ ∈ { N : ℕ | Ramsey₂_prop N 1 k.succ } 
-- → M₂ ∈ { N : ℕ | Ramsey₂_prop N 1 k.succ },
-- intros M₁ M₂ M₁leM₂,
-- simp,
-- intro M₁Ramsey,
-- apply Ramsey_monotone M₁Ramsey M₁leM₂,
-- rewrite nat.Inf_upward_closed_eq_succ_iff (Ramsey1_monotone),
-- simp,
-- split,
-- apply Ramsey₂1_prop 0 k.succ,
-- simp [Ramsey₂_prop, Ramsey_prop]
-- end

-- def monochromatic_vicinity {α : Type} [fintype α] {c : ℕ} (g : simple_graph α) [decidable_rel g.adj] (v : α) (f : sym2 α → fin c) (i : fin c) : finset α := finset.filter (λ x, f ⟦(v, x)⟧ = i) (g.neighbor_finset v)

-- lemma monochromatic_vicinity_Ramsey {N c : ℕ} : ∀ (v : fin N) (f : sym2 (fin N) → fin c) (i : fin c) (s : vector ℕ c), Ramsey_prop (monochromatic_vicinity (complete_graph (fin N)) v f i).card c s → (∃ S, (graph_at_color (complete_graph (fin N)) f i).is_n_clique (s.nth i).succ S) ∨ (∃ i' S, i' ≠ i ∧ (graph_at_color (complete_graph (fin N)) f i').is_n_clique (s.nth i') S) :=
-- begin
-- intros _ _ _ _ Ramsey,
-- unfold Ramsey_prop at Ramsey,
-- cases Ramsey with cardgt0 vicinityProp,
-- have cardeq : (finset.card (@finset.univ (fin (monochromatic_vicinity (complete_graph (fin N)) v f i).card) _)) = (monochromatic_vicinity (complete_graph (fin N)) v f i).card := by simp,
-- have ftrans := bijection_of_eq_card cardeq,
-- simp at ftrans,
-- cases ftrans,
-- simp [(finset.card_eq_zero.mpr ftrans.right)] at cardgt0,
-- cases cardgt0,
-- simp,
-- rcases ftrans with ⟨ftrans, ftransbij⟩,
-- have ftransembinj : function.injective ((λ x, ↑(ftrans ⟨x, finset.mem_univ x⟩)):(fin (monochromatic_vicinity (complete_graph (fin N)) v f i).card → fin N)),
-- intros _ _ fa₁a₂,
-- simp at fa₁a₂,
-- have a₁a₂eq := ftransbij.left (subtype.ext fa₁a₂),
-- simp at a₁a₂eq,
-- exact a₁a₂eq,
-- let ftransemb : function.embedding (fin (monochromatic_vicinity (complete_graph (fin N)) v f i).card) (fin N) := ⟨λ x, ↑(ftrans ⟨x, finset.mem_univ x⟩), ftransembinj⟩,
-- cases vicinityProp (λ e, f ⟦(ftrans ⟨e.out.1, _⟩, ftrans ⟨e.out.2, _⟩)⟧) with S clique; continue { simp },
-- rcases clique with ⟨i', Sclique⟩,
-- cases (fin.decidable_eq c i' i),

-- right,
-- use [i'],
-- simp [h],
-- use [S.map ftransemb],
-- constructor,
-- simp [simple_graph.is_clique_iff, set.pairwise, graph_at_color],
-- intros _ ainS b binS ftransneq,
-- have ftransaprop := (ftrans ⟨a, finset.mem_univ a⟩).prop,
-- simp at ftransaprop,
-- simp [ftransneq],
-- simp [simple_graph.is_clique_iff, set.pairwise, graph_at_color] at Sclique,
-- cases (fin.decidable_eq _ a b) with aneqb aeqb,
-- have abedge := Sclique.clique ainS binS aneqb,
-- simp at abedge,
-- cases' quotient.mk_out (a, b),
-- rw ← cases_eq at abedge,
-- simp at abedge,
-- exact abedge.right,
-- rw ← cases_eq at abedge,
-- simp at abedge,
-- rw [sym2.eq_swap],
-- exact abedge.right,
-- rw ← @subtype.mk_eq_mk (fin (monochromatic_vicinity (complete_graph (fin N)) v f i).card) (λ x, x ∈ finset.univ) a (finset.mem_univ a) b (finset.mem_univ b) at aeqb,
-- have ftranseq := congr_arg ftrans aeqb,
-- rw subtype.ext_iff at ftranseq,
-- cases ftransneq ftranseq,
-- simp [Sclique.card_eq],

-- left,
-- use (insert v (S.map ftransemb)),
-- constructor,
-- simp [simple_graph.is_clique_iff, set.pairwise, graph_at_color],
-- split,
-- intros _ ainS ftransa,
-- have ftransaprop := (ftrans ⟨a, finset.mem_univ a⟩).prop,
-- simp [monochromatic_vicinity] at ftransaprop,
-- exact ftransaprop,
-- intros _ ainS,
-- have ftransaprop := (ftrans ⟨a, finset.mem_univ a⟩).prop,
-- simp [monochromatic_vicinity] at ftransaprop,
-- split,
-- rw [sym2.eq_swap],
-- intros ftransa,
-- simp [ftransa, ftransaprop.right],
-- intros b binS ftransneq,
-- simp [ftransneq],
-- simp [simple_graph.is_clique_iff, set.pairwise, graph_at_color] at Sclique,
-- cases (fin.decidable_eq _ a b) with aneqb aeqb,
-- have abedge := Sclique.clique ainS binS aneqb,
-- simp at abedge,
-- cases' quotient.mk_out (a, b),
-- rw ← cases_eq at abedge,
-- simp [h] at abedge,
-- exact abedge.right,
-- rw ← cases_eq at abedge,
-- simp [h] at abedge,
-- rw [sym2.eq_swap],
-- exact abedge.right,
-- rw ← @subtype.mk_eq_mk (fin (monochromatic_vicinity (complete_graph (fin N)) v f i).card) (λ x, x ∈ finset.univ) a (finset.mem_univ a) b (finset.mem_univ b) at aeqb,
-- have ftranseq := congr_arg ftrans aeqb,
-- rw subtype.ext_iff at ftranseq,
-- cases ftransneq ftranseq,
-- have vnotinSmap : v ∉ (S.map ftransemb),
-- simp [ftransemb],
-- intros a aprop ftransa,
-- have ftransat := (ftrans ⟨a, finset.mem_univ a⟩).prop,
-- simp [ftransa, monochromatic_vicinity] at ftransat,
-- exact ftransat,
-- rw finset.card_insert_of_not_mem vnotinSmap,
-- simp [Sclique.card_eq, h]
-- end

-- theorem Ramsey₂_prop_ineq : ∀ M N s t : ℕ, Ramsey₂_prop M s.succ t.succ.succ → Ramsey₂_prop N s.succ.succ t.succ → Ramsey₂_prop (M + N) s.succ.succ t.succ.succ :=
-- begin
-- intros _ _ _ _ RamseyM RamseyN,
-- have NMpos : M + N > 0 := by simp [nat.add_lt_add RamseyM.left RamseyN.left],
-- unfold Ramsey₂_prop Ramsey_prop,
-- split,
-- assumption,
-- intro,
-- rcases (nat.exists_eq_succ_of_ne_zero (ne.symm (ne_of_lt NMpos.lt))) with ⟨NM, NMprop⟩,
-- haveI finNMzero : has_zero (fin (M + N)),
-- rw NMprop,
-- apply fin.has_zero,
-- let g : fin 2 → ℚ := λ x, (monochromatic_vicinity (complete_graph (fin (M + N))) 0 f x).card,
-- let h : fin 2 → ℚ := ![↑M - rat.mk 1 2, ↑N - rat.mk 1 2],
-- have hgsum : finset.univ.sum h = finset.univ.sum g,
-- -- have univexpand : (@finset.univ (fin 2) _) = {0, 1},
-- -- symmetry,
-- -- rw finset.eq_univ_iff_forall,
-- -- intros,
-- -- fin_cases x; simp,
-- rw univexpand,
-- simp [h, g],
-- have lhs :  ↑M - rat.mk 1 2 + (↑N - rat.mk 1 2) =
-- ↑M + ↑N - 1,
-- abel,
-- simp,
-- rw [← rat.inv_def],
-- apply rat.mul_inv_cancel,
-- simp,
-- simp [lhs],
-- rcases (nat.exists_eq_succ_of_ne_zero (ne_of_gt NMpos.lt)) with ⟨O, Oprop⟩,
-- have filterdisj : disjoint (monochromatic_vicinity (complete_graph (fin (M + N))) 0 f 0) (monochromatic_vicinity (complete_graph (fin (M + N))) 0 f 1),
-- rw finset.disjoint_iff_ne,
-- intros _ ainS _ binT,
-- simp [monochromatic_vicinity] at ainS binT,
-- intro aeqb,
-- rw aeqb at ainS,
-- cases eq.trans (eq.symm binT.right) ainS.right,
-- rw [rat.coe_nat_eq_mk (monochromatic_vicinity ⊤ 0 f 0).card, rat.coe_nat_eq_mk (monochromatic_vicinity ⊤ 0 f 1).card],
-- simp,
-- rw ← int.coe_nat_add,
-- simp at filterdisj,
-- rw ← finset.card_union_eq filterdisj,
-- have seteq : (monochromatic_vicinity ⊤ 0 f 0) ∪ (monochromatic_vicinity ⊤ 0 f 1) = ((complete_graph (fin (M + N))).neighbor_finset 0),
-- apply subset_antisymm; unfold has_subset.subset,
-- intros _ ainset,
-- simp [monochromatic_vicinity] at ainset ⊢,
-- cases ainset with aprop aprop; exact aprop.left,
-- intros _ ainset,
-- simp at ainset ⊢,

-- let fa := f ⟦(0, a)⟧,
-- fin_cases fa; simp [monochromatic_vicinity, ← fa, this, ainset],
-- rw [seteq, simple_graph.neighbor_finset_eq_filter],
-- simp [complete_graph, finset.filter_ne,rat.coe_nat_eq_mk N, rat.coe_nat_eq_mk M],
-- rw [← int.coe_nat_add M N, ← rat.mk_one_one, rat.sub_def (ne_of_gt int.zero_lt_one) (ne_of_gt int.zero_lt_one)],
-- simp[Oprop],
-- have mp := missing_pigeonhole (exists.intro (0 : fin 2) (finset.mem_univ (0 : fin 2))) (le_of_eq hgsum),
-- rcases mp with ⟨a, ainuniv, gha⟩,
-- fin_cases a; simp [g, h] at gha,

-- have MtoZ : (↑M:ℚ) = (↑M:ℤ) := by simp,
-- rw MtoZ at gha,
-- rw ← rat.le_floor at gha,

-- have MleqNeighbor0 := floormagic M (monochromatic_vicinity (complete_graph (fin (M + N))) 0 f 0).card (rat.mk_nat 1 2) halflt1 gha,
-- have cliquecases := monochromatic_vicinity_Ramsey 0 f 0 ⟨[s.succ, t.succ.succ], by simp⟩ (Ramsey_monotone RamseyM MleqNeighbor0),
-- cases cliquecases,
-- cases cliquecases with S Sclique,
-- use [S, 0],
-- exact Sclique,
-- rcases cliquecases with ⟨i, ⟨S, Sclique⟩⟩,
-- use [S, 1],
-- have ieq1 := notc Sclique.left (fin.succ_ne_zero 0),
-- simp [ieq1] at Sclique,
-- exact Sclique,

-- have NtoZ : (↑N:ℚ) = (↑N:ℤ) := by simp,
-- rw NtoZ at gha,
-- rw ← rat.le_floor at gha,
-- have NleqNeighbor1 := floormagic N (monochromatic_vicinity (complete_graph (fin (M + N))) 0 f 1).card (rat.mk_nat 1 2) halflt1 gha,
-- have cliquecases := monochromatic_vicinity_Ramsey 0 f 1 ⟨[s.succ.succ, t.succ], by simp⟩ (Ramsey_monotone RamseyN NleqNeighbor1),
-- cases cliquecases,
-- cases cliquecases with T Tclique,
-- use [T, 1],
-- exact Tclique,
-- rcases cliquecases with ⟨i, ⟨T, Tclique⟩⟩,
-- use [T, 0],
-- have ineq1 := notc Tclique.left fin.zero_ne_one,
-- simp [ineq1] at Tclique,
-- exact Tclique,

-- end

-- theorem Ramsey₂_prop_strict_ineq : ∀ M N s t : ℕ, even M → even N → Ramsey₂_prop M s.succ t.succ.succ → Ramsey₂_prop N s.succ.succ t.succ → Ramsey₂_prop (M + N).pred s.succ.succ t.succ.succ :=
-- begin
-- intros _ _ _ _ evenM evenN RamseyM RamseyN,
-- rcases (nat.exists_eq_succ_of_ne_zero (ne.symm (ne_of_lt RamseyM.left))) with ⟨M', rfl⟩,
-- rcases (nat.exists_eq_succ_of_ne_zero (ne.symm (ne_of_lt RamseyN.left))) with ⟨N', rfl⟩,
-- simp [nat.succ_add, nat.add_succ],
-- unfold Ramsey₂_prop Ramsey_prop,
-- split,
-- simp,
-- intro,
-- let g : fin 2 → ℕ := (λ x, 2 * (finset.filter (λ e, f e = x) (⊤ : simple_graph (fin (M' + N').succ)).edge_finset).card),
-- let h : fin 2 → ℕ := ![(M' + N').succ * M', (M' + N').succ * N'],
-- have hgsum : finset.univ.sum h = finset.univ.sum g,
-- -- have univexpand : (@finset.univ (fin 2) _) = {0, 1},
-- -- symmetry,
-- -- rw finset.eq_univ_iff_forall,
-- -- intros,
-- -- fin_cases x; simp,
-- rw univexpand,
-- simp [h, g],
-- rw [← nat.left_distrib, ← nat.left_distrib],
-- have filterdisj : disjoint (finset.filter (λ e, f e = 0) (⊤ : simple_graph (fin (M' + N').succ)).edge_finset) (finset.filter (λ e, f e = 1) (⊤ : simple_graph (fin (M' + N').succ)).edge_finset),
-- simp[finset.disjoint_iff_ne],
-- intros a _ fa0 b _ fb1,
-- by_contra,
-- simp [h,fb1] at fa0,
-- exact fa0,
-- rw ← finset.card_union_eq filterdisj,
-- have seteq : (finset.filter (λ (e : sym2 (fin (M' + N').succ)), f e = 0) (⊤ : simple_graph (fin (M' + N').succ)).edge_finset ∪ finset.filter (λ (e : sym2 (fin (M' + N').succ)), f e = 1) (⊤ : simple_graph (fin (M' + N').succ)).edge_finset) = (⊤ : simple_graph (fin (M' + N').succ)).edge_finset,
-- simp[finset.subset.antisymm_iff,finset.subset_iff],
-- split, 
-- intros _ xprop; cases xprop; exact xprop.left,
-- intros _ xprop,  
-- let fx := f x,
-- fin_cases fx; simp[← fx, this];exact xprop,

-- rw [seteq, ← simple_graph.sum_degrees_eq_twice_card_edges],
-- simp,
-- have mp := missing_pigeonhole (exists.intro (0 : fin 2) (finset.mem_univ (0 : fin 2))) (nat.le_of_eq hgsum),
-- rcases mp with ⟨a, ainuniv, gha⟩,

-- have cardodd : odd (M' + N').succ,
-- simp[← nat.even_add_one],
-- rw[← nat.succ_add, nat.add_assoc, nat.add_one],
-- simp[nat.even_add, evenM, evenN],

-- fin_cases a; simp [g, h] at gha,

-- have evenrhs : even (2 * (finset.filter (λ (e : sym2 (fin (M' + N').succ)), f e = 0) (⊤ : simple_graph (fin (M' + N').succ)).edge_finset).card) := by simp,
-- have xoreven : xor (even ((M' + N').succ * M')) (even (2 * (finset.filter (λ (e : sym2 (fin (M' + N').succ)), f e = 0) (⊤ : simple_graph (fin (M' + N').succ)).edge_finset).card)),
-- right,
-- simp,
-- rw [← nat.add_one, nat.even_add_one, ← nat.odd_iff_not_even] at evenM,
-- have oddlhs := nat.odd_mul.mpr ⟨cardodd, evenM⟩,
-- simp at oddlhs,
-- exact oddlhs,
-- have ghalt := xor_even_le_implies_lt xoreven gha,

-- rw [dblcnt M' N' f 0] at ghalt,
-- have pghineq : (@finset.univ (fin (M' + N').succ) _).card • M' < ↑((finset.filter (λ (x : (⊤ : simple_graph (fin (M' + N').succ)).dart), f ⟦x.to_prod⟧ = 0) finset.univ).card) := by simp [ghalt],
-- have pgh := finset.exists_lt_card_fiber_of_mul_lt_card_of_maps_to (λ (e : (⊤ : simple_graph (fin (M' + N').succ)).dart) _, finset.mem_univ e.snd) pghineq,
-- rcases pgh with ⟨v, vmem, vprop⟩,
-- simp at vprop,
-- have cardeq : (finset.filter (λ (x : (⊤ : simple_graph (fin (M' + N').succ)).dart), x.to_prod.snd = v)
--        (finset.filter (λ (x : (⊤ : simple_graph (fin (M' + N').succ)).dart), f ⟦x.to_prod⟧ = 0) finset.univ)).card = (monochromatic_vicinity (⊤ : simple_graph (fin (M' + N').succ)) v f 0).card,
-- apply finset.card_congr (λ (a : (⊤ : simple_graph (fin (M' + N').succ)).dart) ainS, a.fst),
-- intro,
-- simp [monochromatic_vicinity],
-- intros f0 asndv,
-- split,
-- intro afstv,
-- have aprop := a.is_adj,
-- simp [asndv, ← afstv] at aprop,
-- exact aprop,
-- simp [sym2.eq_swap, ← asndv],
-- exact f0,
-- intros _ _,
-- simp,
-- intros fa asndv fb bsndv abfst,
-- rw simple_graph.dart.ext_iff,
-- rw prod.ext_iff,
-- simp [abfst, asndv, bsndv],
-- intro,
-- simp [monochromatic_vicinity],
-- intros bnotv fvb0,
-- use (b, v); simp,
-- tauto,
-- simp [sym2.eq_swap, fvb0],
-- rw cardeq at vprop,
-- have cliquecases := monochromatic_vicinity_Ramsey v f 0 ⟨[s.succ, t.succ.succ], by simp⟩ (Ramsey_monotone RamseyM vprop),
-- cases cliquecases,
-- cases cliquecases with S Sclique,
-- use [S, 0],
-- exact Sclique,
-- rcases cliquecases with ⟨i, ⟨S, Sclique⟩⟩,
-- use [S, 1],
-- have ieq1 := notc Sclique.left (fin.succ_ne_zero 0),
-- simp [ieq1] at Sclique,
-- exact Sclique,

-- have evenrhs : even (2 * (finset.filter (λ (e : sym2 (fin (M' + N').succ)), f e = 1) (⊤ : simple_graph (fin (M' + N').succ)).edge_finset).card) := by simp,
-- have xoreven : xor (even ((M' + N').succ * N')) (even (2 * (finset.filter (λ (e : sym2 (fin (M' + N').succ)), f e = 1) (⊤ : simple_graph (fin (M' + N').succ)).edge_finset).card)),
-- right,
-- simp,
-- rw [← nat.add_one, nat.even_add_one, ← nat.odd_iff_not_even] at evenN,
-- have oddlhs := nat.odd_mul.mpr ⟨cardodd, evenN⟩,
-- simp at oddlhs,
-- exact oddlhs,
-- have ghalt := xor_even_le_implies_lt xoreven gha,
-- rw [dblcnt M' N' f 1] at ghalt,
-- have pghineq : (@finset.univ (fin (M' + N').succ) _).card • N' < ↑((finset.filter (λ (x : (⊤ : simple_graph (fin (M' + N').succ)).dart), f ⟦x.to_prod⟧ = 1) finset.univ).card) := by simp [ghalt],
-- have pgh := finset.exists_lt_card_fiber_of_mul_lt_card_of_maps_to (λ (e : (⊤ : simple_graph (fin (M' + N').succ)).dart) _, finset.mem_univ e.snd) pghineq,
-- rcases pgh with ⟨v, vmem, vprop⟩,
-- simp at vprop,
-- have cardeq : (finset.filter (λ (x : (⊤ : simple_graph (fin (M' + N').succ)).dart), x.to_prod.snd = v)
--        (finset.filter (λ (x : (⊤ : simple_graph (fin (M' + N').succ)).dart), f ⟦x.to_prod⟧ = 1) finset.univ)).card = (monochromatic_vicinity (⊤ : simple_graph (fin (M' + N').succ)) v f 1).card,
-- apply finset.card_congr (λ (a : (⊤ : simple_graph (fin (M' + N').succ)).dart) ainS, a.fst),
-- intro,
-- simp [monochromatic_vicinity],
-- intros f1 asndv,
-- split,
-- intro afstv,
-- have aprop := a.is_adj,
-- simp [asndv, ← afstv] at aprop,
-- exact aprop,
-- simp [sym2.eq_swap, ← asndv],
-- exact f1,
-- intros _ _,
-- simp,
-- intros fa asndv fb bsndv abfst,
-- rw simple_graph.dart.ext_iff,
-- rw prod.ext_iff,
-- simp [abfst, asndv, bsndv],
-- intro,
-- simp [monochromatic_vicinity],
-- intros bnotv fvb1,
-- use (b, v); simp,
-- tauto,
-- simp [sym2.eq_swap, fvb1],
-- rw cardeq at vprop,
-- have cliquecases := monochromatic_vicinity_Ramsey v f 1 ⟨[s.succ.succ, t.succ], by simp⟩ (Ramsey_monotone RamseyN vprop),
-- cases cliquecases,
-- cases cliquecases with T Tclique,
-- use [T, 1],
-- exact Tclique,
-- rcases cliquecases with ⟨i, ⟨T, Tclique⟩⟩,
-- use [T, 0],
-- have ineq1 := notc Tclique.left fin.zero_ne_one,
-- simp [ineq1] at Tclique,
-- exact Tclique,
-- end

-- theorem Ramsey₂_finite : ∀ s t : ℕ, { N : ℕ | Ramsey₂_prop N s.succ t.succ }.nonempty :=
-- begin
-- suffices Ramsey₂_finite_additive : ∀ m : ℕ, ∀ s t, m = s + t → { N : ℕ | Ramsey₂_prop N s.succ t.succ }.nonempty,
-- intros,
-- apply (Ramsey₂_finite_additive (s + t) s t),
-- simp,
-- intro,
-- induction m with st ih,
-- intros _ _ h,
-- have h' := eq.symm h,
-- simp at h',
-- cases h' with s0 t0,
-- simp [s0, t0],
-- use 1,
-- simp,
-- simp [Ramsey₂_prop, Ramsey_prop],
-- intro,
-- use [{0}, 0],
-- constructor; simp [simple_graph.is_clique_iff, set.pairwise, vector.head],
-- intros _ _ h,
-- cases s; cases t,
-- use 1,
-- use 1,
-- simp,
-- apply Ramsey₂1_prop,
-- use 1,
-- simp,
-- rw Ramsey₂_prop_symm,
-- apply Ramsey₂1_prop,
-- have s1t : st = s + t.succ,
-- have stsuccpred := congr_arg nat.pred h,
-- simp at stsuccpred,
-- rw stsuccpred,
-- simp [nat.succ_add],
-- have st1 : st = s.succ + t,
-- have stsuccpred := congr_arg nat.pred h,
-- simp at stsuccpred,
-- rw stsuccpred,
-- simp [nat.add_succ],
-- have RamseyS := ih s t.succ s1t,
-- have RamseyT := ih s.succ t st1,
-- cases RamseyS with S Sprop,
-- cases RamseyT with T Tprop,
-- simp at Sprop Tprop,
-- use (S + T),
-- simp,
-- apply Ramsey₂_prop_ineq; assumption,
-- end

-- theorem Ramsey₂_ineq : ∀ s t : ℕ, Ramsey₂ s.succ.succ t.succ.succ ≤ Ramsey₂ s.succ t.succ.succ + Ramsey₂ s.succ.succ t.succ :=
-- begin
-- intros,
-- have RamseyM := nat.Inf_mem (Ramsey₂_finite s t.succ),
-- have RamseyN := nat.Inf_mem (Ramsey₂_finite s.succ t),
-- simp at RamseyM RamseyN,
-- apply nat.Inf_le,
-- simp,
-- apply Ramsey₂_prop_ineq; assumption
-- end

-- theorem Ramsey₂_strict_ineq : ∀ s t : ℕ, even (Ramsey₂ s.succ t.succ.succ) → even (Ramsey₂ s.succ.succ t.succ) → Ramsey₂ s.succ.succ t.succ.succ < Ramsey₂ s.succ t.succ.succ + Ramsey₂ s.succ.succ t.succ :=
-- begin 
-- intros _ _ evenM evenN,
-- have lt_or_eq := decidable.lt_or_eq_of_le (Ramsey₂_ineq s t),
-- cases lt_or_eq,
-- exact lt_or_eq,

-- have temp := Ramsey₂_prop_strict_ineq (Ramsey₂ s.succ t.succ.succ)(Ramsey₂ s.succ.succ t.succ) (s) (t) evenM evenN,
-- unfold Ramsey₂ at temp,
-- have RamseyM := nat.Inf_mem (Ramsey₂_finite s t.succ),
-- have RamseyN := nat.Inf_mem (Ramsey₂_finite s.succ t),
-- simp at RamseyM RamseyN,
-- unfold Ramsey₂ at lt_or_eq,

-- have pos : (Inf {N : ℕ | Ramsey₂_prop N s.succ t.succ.succ} + Inf {N : ℕ | Ramsey₂_prop N s.succ.succ t.succ}) ≠ 0,
-- simp[← lt_or_eq],
-- by_contra,
-- cases h,
-- unfold Ramsey₂_prop at h,
-- unfold Ramsey_prop at h,
-- simp at h,
-- exact h,
-- have contra := Ramsey₂_finite s.succ t.succ,
-- simp [h] at contra,
-- exact contra,

-- have pred_lt : (Inf {N : ℕ | Ramsey₂_prop N s.succ t.succ.succ} + Inf {N : ℕ | Ramsey₂_prop N s.succ.succ t.succ}).pred < 
-- (Inf {N : ℕ | Ramsey₂_prop N s.succ t.succ.succ} + Inf {N : ℕ | Ramsey₂_prop N s.succ.succ t.succ}) := by simp[ nat.pred_lt pos],

-- have pred_in_set : (Inf {N : ℕ | Ramsey₂_prop N s.succ t.succ.succ} + 
-- Inf {N : ℕ | Ramsey₂_prop N s.succ.succ t.succ}).pred ∈ 
-- {N : ℕ | Ramsey₂_prop N s.succ.succ t.succ.succ} := by simp[temp RamseyM RamseyN],

-- have le_pred :=  nat.Inf_le pred_in_set,
-- simp[lt_or_eq] at le_pred,
-- have absurd := lt_of_le_of_lt le_pred pred_lt,
-- simp at absurd,
-- contradiction,

-- end


-- theorem Ramsey₂_symm : ∀  s t: ℕ, Ramsey₂ s.succ t.succ = Ramsey₂ t.succ s.succ :=
-- begin
-- intros,
-- apply nat.le_antisymm,
-- have RamseyM := nat.Inf_mem (Ramsey₂_finite t s),
-- apply nat.Inf_le,
-- simp [Ramsey₂] at RamseyM ⊢,
-- rw Ramsey₂_prop_symm at RamseyM,
-- assumption,
-- have RamseyN := nat.Inf_mem (Ramsey₂_finite s t),
-- apply nat.Inf_le,
-- simp [Ramsey₂] at RamseyN ⊢,
-- rw Ramsey₂_prop_symm at RamseyN,
-- assumption
-- end

-- theorem friendship_upper_bound_alt : Ramsey₂ 3 3 ≤ 6 :=
-- begin
-- have R33 := Ramsey₂_ineq 1 1,
-- rw [Ramsey₂_symm 2 1, Ramsey₂2] at R33,
-- exact R33
-- end

-- theorem friendship : Ramsey₂ 3 3 = 6 := sorry

-- theorem Ramsey₂_binomial_coefficient_ineq : ∀ s t : ℕ, Ramsey₂ s.succ t.succ 
-- ≤ nat.choose (s.succ + t.succ - 2) (s.succ - 1) :=
-- begin
-- intros,

-- induction s with s' ihp₁ generalizing t,
-- simp,
-- rw Ramsey₂1 t,

-- induction t with t' ihp₂,
-- rw Ramsey₂_symm,
-- simp [Ramsey₂1 s'.succ],
-- transitivity Ramsey₂ s'.succ t'.succ.succ + Ramsey₂ s'.succ.succ t'.succ,
-- apply Ramsey₂_ineq s' t', 

-- have temp₁: Ramsey₂ s'.succ t'.succ.succ + Ramsey₂ s'.succ.succ t'.succ
-- ≤ (s'.succ + t'.succ.succ - 2).choose s' + (s'.succ.succ + t'.succ - 2).choose s'.succ,
-- apply add_le_add,
-- exact ihp₁ t'.succ,
-- exact ihp₂,

-- have temp₂ :(s'.succ.succ + t'.succ.succ - 2).choose (s'.succ.succ - 1) = 
-- (s'.succ + t'.succ.succ - 2).choose s' + (s'.succ.succ + t'.succ - 2).choose s'.succ
-- := by simp [nat.succ_add, nat.add_succ,nat.choose_succ_succ],
-- rw temp₂,
-- exact temp₁,
-- end
